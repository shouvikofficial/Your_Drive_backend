import os
import shutil
from pathlib import Path
from fastapi import APIRouter, UploadFile, File, Form, HTTPException
from fastapi.responses import JSONResponse
from app.telegram_bot import client, init_telethon, CHAT_ID

router = APIRouter()

# ============================================================
# üìÇ TEMP STORAGE CONFIG
# ============================================================
TEMP_UPLOAD_DIR = Path("temp_uploads")
TEMP_UPLOAD_DIR.mkdir(exist_ok=True)

# ============================================================
# üöÄ CHUNK UPLOAD ENDPOINT
# ============================================================
@router.post("/upload-chunk")
async def upload_chunk(
    file: UploadFile = File(...),
    chunk_index: int = Form(...),
    total_chunks: int = Form(...),
    file_name: str = Form(...),
    upload_id: str = Form(...),  # Required: Generated by Flutter
):
    """
    Receives file chunks, saves them, and assembles the file 
    when all chunks are present.
    """
    
    # 1. Create a unique session folder for this specific file upload
    # Path: temp_uploads/174829182_999/
    session_dir = TEMP_UPLOAD_DIR / upload_id
    session_dir.mkdir(exist_ok=True)

    # 2. Save the current chunk safely
    # Path: temp_uploads/174829182_999/chunk_0
    chunk_path = session_dir / f"chunk_{chunk_index}"

    try:
        # Async write is safer for server performance
        content = await file.read()
        with open(chunk_path, "wb") as f:
            f.write(content)
            
        print(f"‚úÖ Saved Chunk {chunk_index + 1}/{total_chunks} for {file_name}")

    except Exception as e:
        print(f"‚ùå Error saving chunk: {e}")
        raise HTTPException(status_code=500, detail="Failed to save chunk")

    # 3. Check if we have ALL chunks
    # We count how many 'chunk_X' files are in the folder
    uploaded_chunks_count = len(list(session_dir.glob("chunk_*")))

    if uploaded_chunks_count < total_chunks:
        # Not finished yet, tell Flutter to keep going
        return JSONResponse(content={
            "status": "chunk_received",
            "chunk_index": chunk_index,
            "message": "Chunk saved"
        })

    # ============================================================
    # üèÅ ALL CHUNKS RECEIVED -> ASSEMBLE & UPLOAD
    # ============================================================
    return await finalize_upload(session_dir, upload_id, file_name, total_chunks)


async def finalize_upload(session_dir: Path, upload_id: str, file_name: str, total_chunks: int):
    """
    Assembles the chunks into one file and uploads it to Telegram.
    """
    print(f"üì¶ All chunks received. Assembling {file_name}...")
    
    final_file_path = TEMP_UPLOAD_DIR / f"{upload_id}_{file_name}"

    try:
        # 1. Reassemble the file
        with open(final_file_path, "wb") as final_file:
            for i in range(total_chunks):
                chunk_path = session_dir / f"chunk_{i}"
                
                if not chunk_path.exists():
                    raise HTTPException(status_code=400, detail=f"Missing chunk {i}")

                with open(chunk_path, "rb") as chunk:
                    final_file.write(chunk.read())

        # 2. Upload to Telegram
        await init_telethon()
        print(f"üöÄ Uploading to Telegram: {file_name}")

        # Send to Telegram (Force as document to keep quality)
        sent_message = await client.send_file(
            CHAT_ID,
            final_file_path,
            caption=file_name,
            force_document=True,
            attributes=[] # Add attributes here if you want to support streaming video
        )

        print(f"‚úÖ Upload Complete! Message ID: {sent_message.id}")

        # 3. Return Success Data to Flutter
        return JSONResponse(content={
            "status": "done",
            "message_id": sent_message.id,
            "file_id": str(sent_message.id),
            "type": sent_message.file.mime_type or "application/octet-stream",
            "file_name": file_name
        })

    except Exception as e:
        print(f"‚ùå Finalization Error: {e}")
        raise HTTPException(status_code=500, detail=str(e))

    finally:
        # 4. CLEANUP: Delete temp files regardless of success/failure
        print("üßπ Cleaning up temp files...")
        try:
            if session_dir.exists():
                shutil.rmtree(session_dir) # Delete chunk folder
            if final_file_path.exists():
                os.remove(final_file_path) # Delete assembled file
        except Exception as cleanup_error:
            print(f"‚ö†Ô∏è Cleanup Warning: {cleanup_error}")